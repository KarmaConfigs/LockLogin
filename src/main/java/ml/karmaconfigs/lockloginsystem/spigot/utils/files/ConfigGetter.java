package ml.karmaconfigs.lockloginsystem.spigot.utils.files;

import ml.karmaconfigs.api.shared.Level;
import ml.karmaconfigs.api.spigot.Console;
import ml.karmaconfigs.api.spigot.karmayaml.FileCopy;
import ml.karmaconfigs.api.spigot.karmayaml.YamlReloader;
import ml.karmaconfigs.lockloginsystem.shared.Lang;
import ml.karmaconfigs.lockloginsystem.spigot.LockLoginSpigot;
import ml.karmaconfigs.lockloginsystem.spigot.utils.StringUtils;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

/*
GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]
 */
public final class ConfigGetter implements LockLoginSpigot {

    private final static File spigot = new File(plugin.getServer().getWorldContainer().getPath(), "spigot.yml");

    private final static File config = new File(plugin.getDataFolder(), "config.yml");
    private final static YamlConfiguration configuration = YamlConfiguration.loadConfiguration(config);

    private static boolean loaded = false;

    public ConfigGetter() {
        if (!config.exists()) {
            FileCopy creator = new FileCopy(plugin, "configs/config_spigot.yml");

            if (creator.copy(config)) {
                try {
                    YamlReloader reloader = new YamlReloader(plugin, config, "configs/config_spigot.yml");
                    if (reloader.reloadAndCopy())
                        configuration.loadFromString(reloader.getYamlString());
                } catch (Throwable e) {
                    logger.scheduleLog(Level.GRAVE, e);
                    logger.scheduleLog(Level.INFO, "Error while reloading config file");
                }
            }
        }

        if (!loaded) {
            manager.reload();
            loaded = true;
        }
    }

    public final boolean isBungeeCord() {
        if (spigot.exists()) {
            YamlConfiguration sp = YamlConfiguration.loadConfiguration(spigot);
            return sp.getBoolean("settings.bungeecord");
        } else {
            try {
                if (spigot.createNewFile()) {
                    Console.send(plugin, "LockLogin detected you are not running in spigot, so spigot.yml doesn't seems to exists, if your server.jar supports BungeeCord" +
                            " and you are using it, enable it in spigot.yml (Generated by LockLogin if it didn't exists)", Level.INFO);
                } else {
                    Console.send(plugin, "An error occurred while trying to generate spigot.yml, (You won't be able to enable bungeecord mode)", Level.INFO);
                }
                YamlConfiguration sp = YamlConfiguration.loadConfiguration(spigot);
                if (!sp.isSet("settings.bungeecord")) {
                    sp.set("settings.bungeecord", false);
                    try {
                        sp.save(spigot);
                    } catch (IOException e) {
                        logger.scheduleLog(Level.GRAVE, e);
                        logger.scheduleLog(Level.INFO, "Error while creating artificial spigot.yml for bungeecord support");
                    }
                }
                return sp.getBoolean("settings.bungeecord");
            } catch (IOException e) {
                logger.scheduleLog(Level.GRAVE, e);
                logger.scheduleLog(Level.INFO, "Error while creating artificial spigot.yml for bungeecord support");
                return false;
            }
        }
    }

    public final boolean advancedFiltering() {
        return configuration.getBoolean("AdvancedFiltering");
    }

    public final Lang getLang() {
        String val = Objects.requireNonNull(configuration.getString("Lang", "en_EN")).toLowerCase();

        switch (val) {
            case "en_en":
            case "english":
                return Lang.ENGLISH;
            case "es_es":
            case "spanish":
                return Lang.SPANISH;
            case "zh_cn":
            case "simplified_chinese":
                return Lang.SIMPLIFIED_CHINESE;
            case "it_it":
            case "italian":
                return Lang.ITALIAN;
            case "pl_pl":
            case "polish":
                return Lang.POLISH;
            case "fr_fr":
            case "french":
                return Lang.FRENCH;
            case "cz_cs":
            case "czech":
                return Lang.CZECH;
            default:
                return Lang.UNKNOWN;
        }
    }

    public final String FileSys() {
        return configuration.getString("AccountSys", "file");
    }

    public final boolean isYaml() {
        return FileSys().equalsIgnoreCase("File") || FileSys().equalsIgnoreCase("file");
    }

    public final boolean isMySQL() {
        if (!isBungeeCord()) {
            return FileSys().equalsIgnoreCase("MySQL") || FileSys().equalsIgnoreCase("mysql");
        } else {
            return false;
        }
    }

    public final boolean FileSysValid() {
        return isYaml() || isMySQL();
    }

    public final String ServerName() {
        return configuration.getString("ServerName", StringUtils.randomString(8));
    }

    public final boolean RegisterBlind() {
        return configuration.getBoolean("Register.Blind", false);
    }

    public final boolean RegisterNausea() {
        return configuration.getBoolean("Register.Nausea", false);
    }

    public final int RegisterOut() {
        return configuration.getInt("Register.TimeOut", 60);
    }

    public final int MaxRegisters() {
        return configuration.getInt("Register.Max", 2);
    }

    public final boolean LoginBlind() {
        return configuration.getBoolean("Login.Blind", true);
    }

    public final boolean LoginNausea() {
        return configuration.getBoolean("Login.Nausea", true);
    }

    public final int LoginOut() {
        return configuration.getInt("Login.TimeOut", 30);
    }

    public final int GetMaxTries() {
        return configuration.getInt("Login.MaxTries", 5);
    }

    public final int BFMaxTries() {
        return configuration.getInt("BruteForce.Tries");
    }

    public final int BFBlockTime() {
        int val = configuration.getInt("BruteForce.BlockTime");

        if (val <= 0)
            val = 30;

        return (int) TimeUnit.MINUTES.toSeconds(val);
    }

    public final boolean AntiBot() {
        return configuration.getBoolean("AntiBot", false);
    }

    public final boolean AllowSameIp() {
        return configuration.getBoolean("AllowSameIp", true);
    }

    public final boolean EnablePins() {
        return configuration.getBoolean("Pin", true);
    }

    public final boolean CheckForUpdates() {
        return configuration.getBoolean("Updater.Check", true);
    }

    public final int UpdateCheck() {
        if (configuration.getInt("Updater.CheckTime", 10) >= 5 && configuration.getInt("Updater.CheckTime", 10) <= 1440) {
            return (int) TimeUnit.MINUTES.toSeconds(configuration.getInt("Updater.CheckTime"));
        } else {
            configuration.set("Updater.CheckTime", 5);
            return (int) TimeUnit.MINUTES.toSeconds(5);
        }
    }

    public final boolean UpdateSelf() {
        return configuration.getBoolean("Updater.AutoUpdate", true);
    }

    public final boolean Enable2FA() {
        return configuration.getBoolean("2FA", true);
    }

    public final boolean HandleSpawn() {
        return configuration.getBoolean("Spawn.Manage", false);
    }

    public final boolean TakeBack() {
        return configuration.getBoolean("Spawn.TakeBack", false);
    }

    public final boolean ClearChat() {
        return configuration.getBoolean("ClearChat", false);
    }

    public final int AccountsPerIp() {
        return configuration.getInt("AccountsPerIp", 2);
    }

    public final boolean CheckNames() {
        return configuration.getBoolean("CheckNames", false);
    }

    public final String BungeeProxy() {
        return configuration.getString("BungeeProxy", "&cPlease, connect through bungeecord proxy!");
    }

    public interface manager {

        static boolean reload() {
            try {
                InputStream stream = plugin.getResource("configs/config_spigot.yml");
                if (stream != null) {
                    YamlReloader reloader = new YamlReloader(plugin, config, "configs/config_spigot.yml");
                    if (reloader.reloadAndCopy()) {
                        configuration.loadFromString(reloader.getYamlString());
                        return true;
                    }
                }
            } catch (Throwable e) {
                logger.scheduleLog(Level.GRAVE, e);
                logger.scheduleLog(Level.INFO, "Error while reloading config file");
            }

            return false;
        }
    }
}
